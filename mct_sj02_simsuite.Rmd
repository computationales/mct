---
title: "Rooting depth by site (Schenk & Jackson, 2002)"
author: "Beni Stocker"
date: "4/30/2019"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
---
  
```{r setup, include=FALSE}
library(dplyr)
library(rbeni)
library(tidyr)
library(purrr)
library(ncdf4)
library(lubridate)
library(extRemes)
library(R.utils)
library(readr)
library(ggplot2)
library(ingestr)

source("R/mct2.R")
source("R/get_plantwhc_mct_bysite.R")
source("R/get_plantwhc_mct_simsuite.R")
source("R/calc_soilparams.R")
source("R/calc_zroot.R")
source("R/extract_return_level.R")
source("R/convert_et.R")
#source("R/extract_pointdata_allsites.R")

dir_climate <- "/Users/benjaminstocker/sofun/output_nc_global_sofun"
dir_fapar <- "~/sofun/input_sj02zroot_sofun/sitedata/fapar/"
```


## Load data

Load ALEXI-ET and WATCH-WFDEI precipitation data for each site. This is prepared by `rscript_get_data_sj02sites.R`. This loads an object called `df_alexi`.
```{r}
load("data/df_alexi_sj02.Rdata")
```

## Look at the data

Some ET data seems to be missing. Is it really?
```{r}
plot_et <- function(df){
  gg <- df %>% 
    ggplot(aes(date, et_mm)) + 
    geom_line() 
  return(gg)
}
test_gg <- df_alexi %>% 
  dplyr::mutate( gg = purrr::map(df, ~plot_et(.)))
```

Problem: The first row in `df_alexi$df` is always NA. This is a bug. Drop the row.
```{r}
df_alexi <- df_alexi %>% 
  mutate(df = purrr::map(df, ~drop_na(., date)))
```

More problem: For some sites, elevation data is missing. How many sites are affected?
```{r}
df_missing <- df_alexi %>% 
  tidyr::unnest(df) %>% 
  dplyr::select(idx, elv) %>% 
  dplyr::distinct() %>% 
  dplyr::filter(is.na(elv))
```

Ingest elevation data for sites from ETOPO1 where it's missing in the original data.
```{r}
df_etopo <- ingest(
  df_alexi %>% 
    dplyr::select(sitename = idx, lon, lat),
  source = "etopo1",
  dir = "~/data/etopo/"
  ) %>% 
  tidyr::unnest(data) %>% 
  rename(idx = sitename, elv_etopo = elv)
```

Add ETOPO1 elevation to df_alexi and compare with data for which elevation is given.
```{r}
df_alexi <- df_alexi %>% 
  tidyr::unnest(df) %>% 
  dplyr::group_by(lon, lat, elv, idx) %>% 
  tidyr::nest() %>% 
  dplyr::rename(df = data) %>% 
  left_join(
    df_etopo,
    by = "idx"
  )
df_alexi %>% 
  analyse_modobs2("elv", "elv_etopo")  
```

Looks ok. Let's fill gaps with this, wrap it inside the data column and re-calculate ET conversion.
```{r}
df_alexi_repaired <- df_alexi %>%
  ungroup() %>% 
  dplyr::mutate(elv = ifelse(is.na(elv), elv_etopo, elv)) %>% 
  dplyr::select(-elv_etopo) %>% 

  ## add elevation to the nested dataframes (repeating same value for each time step)
  tidyr::unnest(df) %>% 
  dplyr::group_by(lon, lat, idx) %>% 
  tidyr::nest() %>% 
  dplyr::rename(df = data) %>% 
  
  ## convert units: get ET in mm d-1
  ## total ET
  dplyr::mutate(et_mm = purrr::map(df, ~convert_et(.$et, .$temp, .$elv))) %>% 
  dplyr::mutate(et_mm = purrr::map(et_mm, ~tibble(et_mm = .))) %>% 
  dplyr::mutate(df    = purrr::map2(df, et_mm, ~bind_cols(.x, .y))) %>% 
  dplyr::select(-et_mm) %>% 
  
  ## correct unwanted renaming
  dplyr::mutate(df = purrr::map(df, ~dplyr::select(., -et_mm))) %>% 
  dplyr::mutate(df = purrr::map(df, ~dplyr::rename(., et_mm = et_mm1)))

save(df_alexi_repaired, file = "data/df_alexi_repaired.Rdata")
```

Check if all is correct for a site where elevation data was given already before and `et_mm` calculated and now re-calculated - should yield identical results.
```{r}
## data for a site where elevation was now recalculated
df1 <- df_alexi %>% 
  dplyr::filter(idx == "AC01a") %>% 
  unnest(df)
df2 <- df_alexi_repaired %>% 
  dplyr::filter(idx == "AC01a") %>% 
  unnest(df)

## ok!
df1 %>%
  ungroup() %>% 
  dplyr::select(idx, date, et_mm_orig = et_mm) %>% 
  left_join(
    df2 %>% 
      ungroup() %>% 
      dplyr::select(idx, date, et_mm_repaired = et_mm),
    by = c("idx", "date")
  ) %>% 
  ggplot() +
  geom_point(aes(x = et_mm_orig, y = et_mm_repaired))

# ## data for a site where elevation was not available before
# df1 <- df_alexi %>% 
#   dplyr::filter(idx == "BF03a") %>% 
#   unnest(df)
# df2 <- df_alexi_repaired %>% 
#   dplyr::filter(idx == "BF03a") %>% 
#   unnest(df)
```

Some sites have exact same locations. Number of rows could be halved if only distinct lon and lat were used:
```{r}
df_alexi_repaired %>% 
  ungroup() %>% 
  dplyr::select(idx, lon, lat) %>% 
  distinct() %>% 
  dim()
df_alexi_repaired %>% 
  ungroup() %>% 
  dplyr::select(lon, lat) %>% 
  distinct() %>% 
  dim()
```

Do some otherwise identical sites differ by elevation? Yes. Some do. -> Might be necessary to use higer resolution precipitation data...
```{r}
df_alexi_repaired %>% 
  ungroup() %>% 
  unnest(df) %>% 
  dplyr::select(idx, lon, lat, elv) %>% 
  dplyr::group_by(idx, lon, lat, elv) %>% 
  nest() %>% 
  dplyr::select(idx, lon, lat, elv) %>% 
  distinct() %>% 
  dim()

df_unique_lon_lat_evl <- df_alexi_repaired %>% 
  ungroup() %>% 
  unnest(df) %>% 
  dplyr::select(lon, lat, elv) %>% 
  dplyr::group_by(lon, lat, elv) %>% 
  nest() %>% 
  dplyr::select(lon, lat, elv) %>% 
  distinct()
df_unique_lon_lat_evl %>% 
  dim()
```

Identify duplicated rows (that have identical lon, lat, and elv).
```{r}
df_alexi_repaired <- df_alexi_repaired %>% 
  ungroup() %>% 
  dplyr::select(lon, lat) %>% 
  mutate(dupl = duplicated(.)) %>% 
  dplyr::select(dupl) %>% 
  bind_cols(
    df_alexi_repaired,
    .
  )
```

Look at some duplicated rows (that have identical lon, lat, and elv): Data should be identical. Yes, for this one it is (didn't check other duplicates).
```{r}
df1 <- df_alexi_repaired %>% 
  dplyr::filter(idx=="AC01b") %>% 
  pull(df)
df2 <- df_alexi_repaired %>% 
  dplyr::filter(idx=="AC01c") %>% 
  pull(df)
all.equal(df1, df2)
```


## Apply the MCT function

Calculate the daily water balance and apply the MCT function to get CWD events in different configurations.
```{r eval=FALSE}
clean_bal <- function(df, varnam_bal, varnam_et, varnam_prec){
  
  ## remove NAs at head and tail      
  df <- rbeni::cutna_headtail_df(df, varnam_bal)
  
  if (any(is.na(df[varnam_bal]))){
    ## linearly interpolate ET
    df[varnam_et] <- rbeni::myapprox(df[varnam_et])
    
    ## re-calculate daily water balance
    df[varnam_bal] <- df[varnam_prec] - df[varnam_et]
  }
  
  return(df)
}

avl_et <- function(df, varnam_et){
  any(!is.na(df[varnam_et]))
}

df_alexi_repaired <- df_alexi_repaired %>%
  dplyr::mutate( df = purrr::map(df, ~mutate(., bal = prec - et_mm))) %>%
  dplyr::mutate( avl_et = purrr::map_lgl(df, ~avl_et(., varnam_et = "et_mm"))) %>%
  dplyr::filter( avl_et ) %>% 
  dplyr::mutate( df = purrr::map(df, ~clean_bal(., varnam_bal = "bal", varnam_prec = "prec", varnam_et = "et_mm"))) %>%
  dplyr::mutate( out_mct_20_80 = purrr::map(df, ~get_plantwhc_mct_bysite(., varname_wbal = "bal", thresh_terminate = 0.2, thresh_drop = 0.8)))
  # dplyr::mutate( out_mct_10_90 = purrr::map(df, ~get_plantwhc_mct_bysite(., varname_wbal = "bal", thresh_terminate = 0.1, thresh_drop = 0.9)))

# list_test <- list()
# sites <- df_alexi_repaired %>% pull(idx)
# for (idx_site in sites){
#   print(idx_site)
#   # idx_site <- "AC08"
#   list_test[[idx_site]] test <- df_alexi_repaired %>% 
#     dplyr::filter(idx == idx_site) %>% 
#     dplyr::mutate( df = purrr::map(df, ~mutate(., bal = prec - et_mm))) %>%
#     dplyr::mutate( avl_et = purrr::map_lgl(df, ~avl_et(., varnam_et = "et_mm"))) %>%
#     dplyr::filter(avl_et) %>% 
#     dplyr::mutate( df = purrr::map(df, ~clean_bal(., varnam_bal = "bal", varnam_prec = "prec", varnam_et = "et_mm"))) %>%
#     
#     dplyr::mutate( out_mct_20_80 = purrr::map(df, ~get_plantwhc_mct_bysite(., varname_wbal = "bal", thresh_terminate = 0.2, thresh_drop = 0.8)))
# }
  
save(df_alexi_repaired, file = "data/df_alexi_repaired.Rdata")
```


The following figure shows the distribution of WHC* values:
```{r}
load("data/ddf_mct_simsuite.Rdata")
df_alexi_repaired %>% 
  dplyr::select(idx, out_mct_20_80) %>% 
  dplyr::mutate(whc_mct = purrr::map_dbl(out_mct_20_80, ~extract_return_level(., 10))) %>% 
  ggplot(aes(x = whc_mct, y = ..count..)) +
  geom_histogram(color = "black", alpha = 0.3, position="identity") +
  labs(title = "Plant rooting zone WHC*", subtitle = "10 y return period, 80% reduction of CWD", x = "WHC* (mm)")
```



## Extract soil texture information

Extract soil information from hi-res HWSD raster files (ideally should extract from shapefiles).
```{r}
vars <- c("ROOTS", "T_SAND", "T_OC", "T_GRAVEL", "T_CLAY", "S_SAND", "S_OC", "S_GRAVEL", "S_CLAY")
df_lonlat <- df_sites %>% 
  distinct(lon, lat, .keep_all = TRUE) %>% 
  dplyr::select(lon, lat) %>% 
  dplyr::mutate(id = 1:n())
  
# extract by file
df_hwsd <- tibble( vars = vars ) %>% 
  dplyr::mutate(filn = paste0("~/data/soil/hwsd/hwsd_wieder/data/", vars, ".nc4")) %>% 
  dplyr::mutate(data = purrr::map(filn, ~extract_pointdata_allsites(., df_lonlat, get_time = FALSE)))

# re-arrange data
df_sites <- df_hwsd %>% 
  tidyr::unnest(data) %>% 
  dplyr::mutate(data = purrr::map_dbl(data, ~unlist(.))) %>% 
  dplyr::select(-filn, -lon, -lat) %>% 
  tidyr::spread(vars, data) %>% 
  dplyr::right_join(df_lonlat, by = "id") %>% 
  dplyr::right_join(df_sites, by = c("lon", "lat"))
```

Calculate FC, PWP, and WHC from texture data.
```{r}
# top-soil
df_sites_topsoil <- df_sites %>%
  dplyr::select(sitename, roots = ROOTS, fclay = T_CLAY, fgravel = T_GRAVEL, forg = T_OC, fsand = T_SAND) %>% 
  dplyr::mutate(fclay   = ifelse(fclay==0 & fgravel ==0 & fsand ==0, NA, fclay),
                fgravel = ifelse(fclay==0 & fgravel ==0 & fsand ==0, NA, fgravel),
                forg    = ifelse(fclay==0 & fgravel ==0 & fsand ==0, NA, forg),
                fsand   = ifelse(fclay==0 & fgravel ==0 & fsand ==0, NA, fsand)) %>% 
  calc_soilparams(method = "balland")

df_sites_topsoil_mean <- df_sites_topsoil %>% 
  dplyr::select(roots, whc) %>% 
  dplyr::group_by() %>% 
  dplyr::summarise_all(list( ~mean(., na.rm=TRUE)))

df_sites_topsoil <- df_sites_topsoil %>% 
  dplyr::mutate( whc = ifelse(is.na(whc), df_sites_topsoil_mean$whc, whc))

# sub-soil
df_sites_subsoil <- df_sites %>%
  dplyr::select(sitename, roots = ROOTS, fclay = S_CLAY, fgravel = S_GRAVEL, forg = S_OC, fsand = S_SAND) %>% 
  dplyr::mutate(fclay   = ifelse(fclay==0 & fgravel ==0 & fsand ==0, NA, fclay),
                fgravel = ifelse(fclay==0 & fgravel ==0 & fsand ==0, NA, fgravel),
                forg    = ifelse(fclay==0 & fgravel ==0 & fsand ==0, NA, forg),
                fsand   = ifelse(fclay==0 & fgravel ==0 & fsand ==0, NA, fsand)) %>% 
  calc_soilparams(method = "balland")

df_sites_subsoil_mean <- df_sites_subsoil %>% 
  dplyr::select(roots, whc) %>% 
  dplyr::group_by() %>% 
  dplyr::summarise_all(list( ~mean(., na.rm=TRUE)))

df_sites_subsoil <- df_sites_subsoil %>% 
  dplyr::mutate( whc = ifelse(is.na(whc), df_sites_subsoil_mean$whc, whc))
```

Plot the distribution of values.
```{r}
df_sites_topsoil %>% 
  ggplot(aes(x = whc, y = ..count..)) +
  geom_histogram(color = "black", alpha = 0.3, position="identity") +
  labs(title = "Top soil WHC", subtitle = " based on HWSD soil texture data", x = "WHC (m3/m3)")

df_sites_subsoil %>% 
  ggplot(aes(x = whc, y = ..count..)) +
  geom_histogram(color = "black", alpha = 0.3, position="identity") +
  labs(title = "Sub soil WHC", subtitle = " based on HWSD soil texture data", x = "WHC (m3/m3)")
```

## Calculate rooting depth.

```{r}
ddf_20y_90t <- ddf %>%
  dplyr::left_join(dplyr::select(df_sites_subsoil, sitename, whc_s = whc, roots), by = "sitename") %>% 
  dplyr::left_join(dplyr::select(df_sites_topsoil, sitename, whc_t = whc), by = "sitename") %>% 
  dplyr::mutate(whc_mct = purrr::map_dbl(out_mct_90, ~extract_return_level(., 20))) %>%
  dplyr::select(sitename, whc_mct, whc_t, whc_s, roots) %>% 
  rowwise() %>% 
  dplyr::mutate(zroot = calc_zroot(whc_mct, whc_t, whc_s, roots))

ddf_10y_95t <- ddf %>%
  dplyr::left_join(dplyr::select(df_sites_subsoil, sitename, whc_s = whc, roots), by = "sitename") %>% 
  dplyr::left_join(dplyr::select(df_sites_topsoil, sitename, whc_t = whc), by = "sitename") %>% 
  dplyr::mutate(whc_mct = purrr::map_dbl(out_mct_95, ~extract_return_level(., 10))) %>%
  dplyr::select(sitename, whc_mct, whc_t, whc_s, roots) %>% 
  rowwise() %>% 
  dplyr::mutate(zroot = calc_zroot(whc_mct, whc_t, whc_s, roots))

ddf_05y_95t <- ddf %>%
  dplyr::left_join(dplyr::select(df_sites_subsoil, sitename, whc_s = whc, roots), by = "sitename") %>% 
  dplyr::left_join(dplyr::select(df_sites_topsoil, sitename, whc_t = whc), by = "sitename") %>% 
  dplyr::mutate(whc_mct = purrr::map_dbl(out_mct_95, ~extract_return_level(., 5))) %>%
  dplyr::select(sitename, whc_mct, whc_t, whc_s, roots) %>% 
  rowwise() %>% 
  dplyr::mutate(zroot = calc_zroot(whc_mct, whc_t, whc_s, roots))
```

The following figure shows the distribution of zroot* values:
```{r}
ddf_05y_95t %>% 
  ggplot(aes(x = zroot, y = ..count..)) +
  geom_histogram(color = "black", alpha = 0.3, position="identity") +
  labs(title = "Plant rooting depth", subtitle = "10 y return period, 95% reduction of D", x = "zroot* (mm)")
```

## Comparison to observations

Combine data frames.
```{r}
df_modobs <- read_csv("/alphadata01/bstocker/data/rootingdepth/root_profiles_schenkjackson02/data/root_profiles_D50D95.csv") %>% 
  dplyr::filter(Wetland == "N" & Anthropogenic == "N" & Schenk_Jackson_2002 == "YES") %>% 
  dplyr::rename(sitename = ID) %>% 
  dplyr::left_join(dplyr::select(ddf_05y_95t, zroot_05y_95t = zroot, sitename), by = "sitename") %>% 
  dplyr::left_join(dplyr::select(ddf_10y_95t, zroot_10y_95t = zroot, sitename), by = "sitename") %>% 
  dplyr::left_join(dplyr::select(ddf_20y_90t, zroot_20y_90t = zroot, sitename), by = "sitename") %>% 
  dplyr::mutate(D50 = 1000 * D50, D95 = 1000 * D95, D50_extrapolated = 1000 * D50_extrapolated, D95_extrapolated = 1000 * D95_extrapolated)
```

### Distribution of values
```{r}
df_modobs %>% 
  dplyr::select(sitename, Vegetation, obs = D95_extrapolated, mod = zroot_05y_95t) %>% 
  tidyr::gather(key = "source", value = "zroot", c(mod, obs)) %>% 
  ggplot() +
  geom_histogram(
    aes(x = zroot, y = ..count.., fill = source), 
    color = "black", alpha = 0.3, position="identity") +
  scale_fill_manual(name = "", values = c("black", "red")) +
  labs(title = "Distribution of rooting depth (mm), v3", x = "Rooting depth (mm)")
ggsave("fig/hist_zroot_modobs.pdf", height = 4, width = 6)
```

### Comparison by vegetation type.
```{r}
df_modobs %>% 
  dplyr::select(sitename, Vegetation, obs = D95_extrapolated, mod = zroot_05y_95t) %>% 
  tidyr::gather(key = "source", value = "zroot", c(mod, obs)) %>% 
  # dplyr::filter(source == "obs") %>% 
  ggplot() +
  geom_boxplot(aes(x = Vegetation, y = -zroot, fill = source)) +
  theme(axis.text.x = element_text(angle=90, hjust=1)) +
  labs(title = "Observed and modelled by vegetation type", subtitle = "Obs.: 95% quantile  Mod.: 5-yr return period, 5% deficit reduction threshold", y = "Rooting depth (mm)")
ggsave("fig/modobs_boxplot_zroot_95_5y.pdf", width = 9, height = 6)

df_modobs %>% 
  dplyr::select(sitename, Vegetation, obs = D95_extrapolated, mod = zroot_20y_90t) %>% 
  tidyr::gather(key = "source", value = "zroot", c(mod, obs)) %>% 
  # dplyr::filter(source == "obs") %>% 
  ggplot() +
  geom_boxplot(aes(x = Vegetation, y = -zroot, fill = source)) +
  theme(axis.text.x = element_text(angle=90, hjust=1)) +
  labs(title = "Observed and modelled by vegetation type", subtitle = "Obs.: 95% quantile  Mod.: 20-yr return period, 10% deficit reduction threshold", y = "Rooting depth (mm)")
```

### Comparison site by site.
```{r}
out <- df_modobs %>% 
  analyse_modobs2(
    mod = "zroot_05y_95t", 
    obs = "D95_extrapolated"
    )
out$gg +  
  labs(
    title = "Obs.: 95% quantile  Mod.: 5-yr return period, 5% deficit reduction threshold", 
    x = "Modelled rooting depth (mm)", 
    y = "Observed rooting depth (mm)"
    )
```
