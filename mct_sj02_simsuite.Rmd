---
title: "Rooting depth by site (Schenk & Jackson, 2002)"
author: "Beni Stocker"
date: "4/30/2019"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
---
  
```{r setup, include=FALSE}
library(dplyr)
library(rbeni)
library(tidyr)
library(purrr)
library(ncdf4)
library(lubridate)
library(extRemes)
library(R.utils)
library(readr)
library(ggplot2)
library(ingestr)

source("R/mct2.R")
source("R/get_plantwhc_mct_bysite.R")
source("R/get_plantwhc_mct_simsuite.R")
source("R/calc_soilparams.R")
source("R/calc_zroot.R")
source("R/extract_return_level.R")
source("R/convert_et.R")
#source("R/extract_pointdata_allsites.R")

dir_climate <- "/Users/benjaminstocker/sofun/output_nc_global_sofun"
dir_fapar <- "~/sofun/input_sj02zroot_sofun/sitedata/fapar/"
```


## Load data

Load ALEXI-ET and WATCH-WFDEI precipitation data for each site. This is prepared by `rscript_get_data_sj02sites.R`. This loads an object called `df_alexi`.
```{r}
load("data/df_alexi_sj02.Rdata")
```

## Look at the data

Some ET data seems to be missing. Is it really?
```{r}
plot_et <- function(df){
  gg <- df %>% 
    ggplot(aes(date, et_mm)) + 
    geom_line() 
  return(gg)
}
test_gg <- df_alexi %>% 
  dplyr::mutate( gg = purrr::map(df, ~plot_et(.)))
```

Problem: The first row in `df_alexi$df` is always NA. This is a bug. Drop the row.
```{r}
df_alexi <- df_alexi %>% 
  mutate(df = purrr::map(df, ~drop_na(., date)))
```

More problem: For some sites, elevation data is missing. How many sites are affected?
```{r}
df_missing <- df_alexi %>% 
  tidyr::unnest(df) %>% 
  dplyr::select(idx, elv) %>% 
  dplyr::distinct() %>% 
  dplyr::filter(is.na(elv))
```

Ingest elevation data for sites from ETOPO1 where it's missing in the original data.
```{r}
df_etopo <- ingest(
  df_alexi %>% 
    dplyr::select(sitename = idx, lon, lat),
  source = "etopo1",
  dir = "~/data/etopo/"
  ) %>% 
  tidyr::unnest(data) %>% 
  rename(idx = sitename, elv_etopo = elv)
```

Add ETOPO1 elevation to df_alexi and compare with data for which elevation is given.
```{r}
df_alexi <- df_alexi %>% 
  tidyr::unnest(df) %>% 
  dplyr::group_by(lon, lat, elv, idx) %>% 
  tidyr::nest() %>% 
  dplyr::rename(df = data) %>% 
  left_join(
    df_etopo,
    by = "idx"
  )
df_alexi %>% 
  analyse_modobs2("elv", "elv_etopo")  
```

Looks ok. Let's fill gaps with this, wrap it inside the data column and re-calculate ET conversion.
```{r}
df_alexi_repaired <- df_alexi %>%
  ungroup() %>% 
  dplyr::mutate(elv = ifelse(is.na(elv), elv_etopo, elv)) %>% 
  dplyr::select(-elv_etopo) %>% 

  ## add elevation to the nested dataframes (repeating same value for each time step)
  tidyr::unnest(df) %>% 
  dplyr::group_by(lon, lat, idx) %>% 
  tidyr::nest() %>% 
  dplyr::rename(df = data) %>% 
  
  ## convert units: get ET in mm d-1
  ## total ET
  dplyr::mutate(et_mm = purrr::map(df, ~convert_et(.$et, .$temp, .$elv))) %>% 
  dplyr::mutate(et_mm = purrr::map(et_mm, ~tibble(et_mm = .))) %>% 
  dplyr::mutate(df    = purrr::map2(df, et_mm, ~bind_cols(.x, .y))) %>% 
  dplyr::select(-et_mm) %>% 
  
  ## correct unwanted renaming
  dplyr::mutate(df = purrr::map(df, ~dplyr::select(., -et_mm))) %>% 
  dplyr::mutate(df = purrr::map(df, ~dplyr::rename(., et_mm = et_mm1)))

save(df_alexi_repaired, file = "data/df_alexi_repaired.Rdata")
```

Check if all is correct for a site where elevation data was given already before and `et_mm` calculated and now re-calculated - should yield identical results.
```{r}
## data for a site where elevation was now recalculated
df1 <- df_alexi %>% 
  dplyr::filter(idx == "AC01a") %>% 
  unnest(df)
df2 <- df_alexi_repaired %>% 
  dplyr::filter(idx == "AC01a") %>% 
  unnest(df)

## ok!
df1 %>%
  ungroup() %>% 
  dplyr::select(idx, date, et_mm_orig = et_mm) %>% 
  left_join(
    df2 %>% 
      ungroup() %>% 
      dplyr::select(idx, date, et_mm_repaired = et_mm),
    by = c("idx", "date")
  ) %>% 
  ggplot() +
  geom_point(aes(x = et_mm_orig, y = et_mm_repaired))

# ## data for a site where elevation was not available before
# df1 <- df_alexi %>% 
#   dplyr::filter(idx == "BF03a") %>% 
#   unnest(df)
# df2 <- df_alexi_repaired %>% 
#   dplyr::filter(idx == "BF03a") %>% 
#   unnest(df)
```

Some sites have exact same locations. Number of rows could be halved if only distinct lon and lat were used:
```{r}
df_alexi_repaired %>% 
  ungroup() %>% 
  dplyr::select(idx, lon, lat) %>% 
  distinct() %>% 
  dim()
df_alexi_repaired %>% 
  ungroup() %>% 
  dplyr::select(lon, lat) %>% 
  distinct() %>% 
  dim()
```

Do some otherwise identical sites differ by elevation? Yes. Some do. -> Might be necessary to use higer resolution precipitation data...
```{r}
df_alexi_repaired %>% 
  ungroup() %>% 
  unnest(df) %>% 
  dplyr::select(idx, lon, lat, elv) %>% 
  dplyr::group_by(idx, lon, lat, elv) %>% 
  nest() %>% 
  dplyr::select(idx, lon, lat, elv) %>% 
  distinct() %>% 
  dim()

df_unique_lon_lat_evl <- df_alexi_repaired %>% 
  ungroup() %>% 
  unnest(df) %>% 
  dplyr::select(lon, lat, elv) %>% 
  dplyr::group_by(lon, lat, elv) %>% 
  nest() %>% 
  dplyr::select(lon, lat, elv) %>% 
  distinct()
df_unique_lon_lat_evl %>% 
  dim()
```

Identify duplicated rows (that have identical lon, lat, and elv).
```{r}
df_alexi_repaired <- df_alexi_repaired %>% 
  ungroup() %>% 
  dplyr::select(lon, lat) %>% 
  mutate(dupl = duplicated(.)) %>% 
  dplyr::select(dupl) %>% 
  bind_cols(
    df_alexi_repaired,
    .
  )
```

Look at some duplicated rows (that have identical lon, lat, and elv): Data should be identical. Yes, for this one it is (didn't check other duplicates).
```{r}
df1 <- df_alexi_repaired %>% 
  dplyr::filter(idx=="AC01b") %>% 
  pull(df)
df2 <- df_alexi_repaired %>% 
  dplyr::filter(idx=="AC01c") %>% 
  pull(df)
all.equal(df1, df2)
```


## Apply the MCT function

Calculate the daily water balance and apply the MCT function to get CWD events in different configurations.
```{r eval=FALSE}
clean_bal <- function(df, varnam_bal, varnam_et, varnam_prec){
  
  ## remove NAs at head and tail      
  df <- rbeni::cutna_headtail_df(df, varnam_bal)
  
  if (any(is.na(df[varnam_bal]))){
    ## linearly interpolate ET
    df[varnam_et] <- rbeni::myapprox(df[varnam_et])
    
    ## re-calculate daily water balance
    df[varnam_bal] <- df[varnam_prec] - df[varnam_et]
  }
  
  return(df)
}

avl_et <- function(df, varnam_et){
  any(!is.na(df[varnam_et]))
}

df_mct_sj02_alexi <- df_alexi_repaired %>%
  dplyr::mutate( df = purrr::map(df, ~mutate(., bal = prec - et_mm))) %>%
  dplyr::mutate( avl_et = purrr::map_lgl(df, ~avl_et(., varnam_et = "et_mm"))) %>%
  dplyr::filter( avl_et ) %>% 
  dplyr::mutate( df = purrr::map(df, ~clean_bal(., varnam_bal = "bal", varnam_prec = "prec", varnam_et = "et_mm"))) %>%
  dplyr::mutate( 
    out_mct_10_90 = purrr::map(
      df, 
      ~get_plantwhc_mct_bysite(
        ., 
        varname_wbal = "bal", 
        thresh_terminate = 0.1, 
        thresh_drop = 0.9, 
        fittype = "Gumbel"))
    )
  # dplyr::mutate( out_mct_10_90 = purrr::map(df, ~get_plantwhc_mct_bysite(., varname_wbal = "bal", thresh_terminate = 0.1, thresh_drop = 0.9)))

# list_test <- list()
# sites <- df_alexi_repaired %>% pull(idx)
# for (idx_site in sites){
#   print(idx_site)
#   # idx_site <- "AC08"
#   list_test[[idx_site]] test <- df_alexi_repaired %>% 
#     dplyr::filter(idx == idx_site) %>% 
#     dplyr::mutate( df = purrr::map(df, ~mutate(., bal = prec - et_mm))) %>%
#     dplyr::mutate( avl_et = purrr::map_lgl(df, ~avl_et(., varnam_et = "et_mm"))) %>%
#     dplyr::filter(avl_et) %>% 
#     dplyr::mutate( df = purrr::map(df, ~clean_bal(., varnam_bal = "bal", varnam_prec = "prec", varnam_et = "et_mm"))) %>%
#     
#     dplyr::mutate( out_mct_20_80 = purrr::map(df, ~get_plantwhc_mct_bysite(., varname_wbal = "bal", thresh_terminate = 0.2, thresh_drop = 0.8)))
# }
  
save(df_mct_sj02_alexi, file = "data/df_mct_sj02_alexi.RData")
```


The following figure shows the distribution of WHC* values:
```{r}
# load("data/ddf_mct_simsuite.Rdata") xxx ??? don't know what this is for
df_mct_sj02_alexi %>% 
  dplyr::select(idx, out_mct_10_90) %>% 
  dplyr::mutate(whc20 = purrr::map_dbl(out_mct_10_90, ~extract_return_level(., 20))) %>% 
  ggplot(aes(x = whc20, y = ..count..)) +
  geom_histogram(color = "black", alpha = 0.3, position="identity") +
  labs(title = "Plant rooting zone WHC*", subtitle = "10 y return period, 80% reduction of CWD", x = "WHC* (mm)")
```


## Extract soil texture information

Using the very nice ingestr package.
```{r}
df_hwsd <- ingest(
  dplyr::select(ungroup(df_mct_sj02_alexi), sitename = idx, lon, lat),
  source = "hwsd",
  settings = list(fil = "~/data/hwsd/HWSD_RASTER/hwsd.bil")
  )
save(df_hwsd, file = "data/df_hwsd.RData")
```

Calculate FC, PWP, and WHC from texture data.
```{r}
## re-organise soil texture data into columns for each site (row)
df_whc <- df_hwsd %>% 
  mutate(data = purrr::map(data, ~slice(., 1))) %>% 
  mutate(
    data_topsoil = purrr::map(data, ~dplyr::select(
      ., fclay = T_CLAY, fgravel = T_GRAVEL, forg = T_OC, fsand = T_SAND, roots = ROOTS, imperm = IL)),
    data_subsoil = purrr::map(data, ~dplyr::select(
      ., fclay = S_CLAY, fgravel = S_GRAVEL, forg = S_OC, fsand = S_SAND, roots = ROOTS, imperm = IL))
    ) %>% 
  dplyr::select(-data) %>% 
  mutate(data_topsoil = purrr::map(data_topsoil, ~calc_soilparams(., method = "balland")),
         data_subsoil = purrr::map(data_subsoil, ~calc_soilparams(., method = "balland")))
```

Plot the distribution of values.
```{r}
df_whc %>% 
  unnest(data_topsoil) %>% 
  ggplot(aes(x = whc, y = ..count..)) +
  geom_histogram(color = "black", alpha = 0.3, position="identity") +
  labs(title = "Top soil WHC", subtitle = " based on HWSD soil texture data", x = "WHC (m3/m3)")

df_whc %>% 
  unnest(data_subsoil) %>% 
  ggplot(aes(x = whc, y = ..count..)) +
  geom_histogram(color = "black", alpha = 0.3, position="identity") +
  labs(title = "Sub soil WHC", subtitle = " based on HWSD soil texture data", x = "WHC (m3/m3)")
```

## Calculate rooting depth.

```{r}
## use CWD10 for zroot, no root obstacles accounted for now
df_zroot <- df_mct_sj02_alexi %>% 
  ungroup() %>% 
  dplyr::select(sitename = idx, out_mct_10_90) %>% 
  dplyr::mutate(whcXX = purrr::map_dbl(out_mct_10_90, ~extract_return_level(., 10))) %>% 
  dplyr::select(sitename, whcXX) %>% 
  left_join(
    df_whc %>% 
      unnest(data_subsoil) %>%
      dplyr::select(sitename, whc_s = whc),
    by = "sitename"
  ) %>% 
  left_join(
    df_whc %>% 
      unnest(data_topsoil) %>%
      dplyr::select(sitename, whc_t = whc, roots, imperm),
    by = "sitename"
  ) %>% 
  rowwise() %>% 
  dplyr::mutate(zroot = calc_zroot(whcXX, whc_t, whc_s, roots, imperm))
```

The following figure shows the distribution of zroot* values:
```{r}
df_zroot %>% 
  ggplot(aes(x = zroot, y = ..count..)) +
  geom_histogram(color = "black", alpha = 0.3, position="identity") +
  labs(title = "Plant rooting depth", subtitle = "10 y return period, 95% reduction of D", x = "zroot* (mm)")
```

## Comparison to observations

Combine data frames.
```{r}
df_modobs <- read_csv("~/data/rootingdepth/root_profiles_schenkjackson02/data/root_profiles_D50D95.csv") %>% 
  dplyr::filter(Wetland == "N" & Anthropogenic == "N" & Schenk_Jackson_2002 == "YES") %>% 
  dplyr::rename(sitename = ID) %>% 
  dplyr::left_join(dplyr::select(df_zroot, zroot, sitename), by = "sitename") %>% 
  dplyr::mutate(D50 = 1000 * D50, D95 = 1000 * D95, D50_extrapolated = 1000 * D50_extrapolated, D95_extrapolated = 1000 * D95_extrapolated)
```

### Distribution of values
```{r}
df_modobs %>% 
  dplyr::select(sitename, Vegetation, obs = D95_extrapolated, mod = zroot) %>% 
  tidyr::pivot_longer(cols = c(mod, obs), names_to = "source", values_to = "zroot") %>% 
  ggplot() +
  geom_histogram(
    aes(x = zroot, y = ..count.., fill = source), 
    color = "black", alpha = 0.3, position="identity") +
  scale_fill_manual(name = "", values = c("black", "red")) +
  labs(title = "Distribution of rooting depth (mm), v3", x = "Rooting depth (mm)")

ggsave("fig/hist_zroot_modobs.pdf", height = 4, width = 6)
```

### Comparison by vegetation type.
```{r}
df_modobs %>% 
  dplyr::select(sitename, Vegetation, obs = D95_extrapolated, mod = zroot) %>% 
  tidyr::pivot_longer(cols = c(mod, obs), names_to = "source", values_to = "zroot") %>% 
  # dplyr::filter(source == "obs") %>% 
  ggplot() +
  geom_boxplot(aes(x = Vegetation, y = -zroot, fill = source)) +
  theme(axis.text.x = element_text(angle=90, hjust=1)) +
  labs(
    title = "Observed and modelled by vegetation type", 
    subtitle = "Obs.: 95% quantile  Mod.: 5-yr return period, 5% deficit reduction threshold", 
    y = "Rooting depth (mm)")

ggsave("fig/modobs_boxplot_zroot.pdf", width = 9, height = 6)
```

### Comparison site by site.
```{r}
out <- df_modobs %>% 
  rbeni::analyse_modobs2(
    mod = "zroot", 
    obs = "D95_extrapolated"
    )
out$gg +  
  labs(
    title = "Obs.: 95% quantile  Mod.: 5-yr return period, 5% deficit reduction threshold", 
    x = "Modelled rooting depth (mm)", 
    y = "Observed rooting depth (mm)"
    )
```

## Check if water table depth is a useful constrait

```{r}
df_modobs <- df_alexi_repaired %>% 
  dplyr::select(idx, lon, lat) %>% 
  ingest_wtd_fan() %>% 
  rename(sitename = idx, wtd_fan13 = wtd) %>% 
  mutate(wtd_fan13 = wtd_fan13 * 1000) %>% 
  right_join(
    df_modobs,
    by = "sitename"
  ) %>% 
  mutate(wtd_fan13 = ifelse(is.na(wtd_fan13), 99999, wtd_fan13)) %>% 
  mutate(zroot_wtd = ifelse(zroot > wtd_fan13, wtd_fan13, zroot))
```

Updated histogram by vegetation type
```{r}
df_modobs %>% 
  dplyr::select(sitename, Vegetation, obs = D95_extrapolated, mod = zroot_wtd) %>% 
  tidyr::pivot_longer(cols = c(mod, obs), names_to = "source", values_to = "zroot") %>% 
  # dplyr::filter(source == "obs") %>% 
  ggplot() +
  geom_boxplot(aes(x = Vegetation, y = -zroot, fill = source)) +
  theme(axis.text.x = element_text(angle=90, hjust=1)) +
  labs(
    title = "Observed and modelled by vegetation type", 
    subtitle = "Obs.: 95% quantile  Mod.: 5-yr return period, 5% deficit reduction threshold", 
    y = "Rooting depth (mm)")

ggsave("fig/modobs_boxplot_zroot_wtd.pdf", width = 9, height = 6)
```

Updated mod. vs. obs.
```{r}
out <- df_modobs %>% 
  rbeni::analyse_modobs2(
    mod = "zroot_wtd", 
    obs = "D95_extrapolated"
    )
out$gg +  
  labs(
    title = "Obs.: 95% quantile  Mod.: 5-yr return period, 5% deficit reduction threshold", 
    x = "Modelled rooting depth (mm)", 
    y = "Observed rooting depth (mm)"
    )
```