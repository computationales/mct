---
title: "Workflow"
author: "Beni Stocker"
date: "6/8/2020"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(rbeni)
library(tidyr)
library(purrr)
library(ncdf4)
library(lubridate)
library(ggplot2)
library(readr)
#library(rsofun)
#library(ingestr)
library(stringr)
#library(ggridges)

#files.sources = list.files("./R")
#out <- sapply(paste0("R/", files.sources), source)
```

## Overview

This workflow can be applied irrespective of the site set or global gridcells. Just need a "grid data frame".

1. **Get site/grid meta info** → data frame with all meta info variables as separate columns
    - elevation
        - Site scale: data or ETOPO1
        - Global: WFDEI
    - soil texture, derive WHC top and bottom, and record obstacles to root used in function `calc_zroot.R`
        - Site scale: HWSD
        - Global: HWSD-Wieder
    - WTD, Fan et al.
        - Site scale: Hi-res Fan
        - Global: Lo-res Fan
    - Biome, WWF, NSCP?
        - Site scale: WWF, extract from shapefile
        - Global: rasterize WWF data?
2. **Extract data**, `rscript_get_data.R`  → separate data frames for each data source, rows: site/gridcell, column: nested data, data: ET (W m-2), prec, snow, temp, elevation; large data! need to separate data frames by chunks for global analyses
    - ALEXI
    - WATCH
    - SIF
    - GLASS net radiation
3. **Convert units, complement, reduce** → Manipulates data frames prepared by step 2, reduced data frames with only 1 column: daily water balance (not cumulative!)
    - ET to mm (done in step 1)
    - Snow water balance
4. **CWD events**, `mct2.R`  → list with (i) water deficit time series, daily and cumulative, dday, iinst; and (ii) events data frame with maximum deficit, start date and length of event
    - Use parameters determined from FLUXNET-sites analysis (`thresh_terminate = 0.0, thresh_drop = 0.9`)
5. **Water deficit extremes CWDX** (maximum event with N year return period), `get_plantwhc_mct_bysite.R`  → data frame with return periods
    - Use 20 year return period for good match of obs and mod at SJ02 sites (see ridges plot)
6. **Rooting depth z(CWDX)**, see `mct_sj02_simsuite.Rmd` → data frame with z(CWDX) for different return periods
    - Use meta info prepared in step 1, including WTD  (Fan), see `mct_sj02_simsuite.Rmd`
7. **Implied zroot using SiF: CWD(LUE=0)**, see `test_mct_bysite_alexi_fluxnet.R` 
    - Use CWD events from step 3 and SiF from step 2
8. **Implied zroot using Rn: CWD(fET=0)**, see `test_mct_bysite_alexi_fluxnet.R`
    - Use CWD events from step 3 and GLASS net radiation from step 2


## Settings

The same overall workflow can be used for different site sets or for global simulations (treating each gridcell as a site). Depending on this scale, some data is read from different sources. 

Define which set is used by uncommenting/commenting:
```{r}
# siteset <- "sj02"
siteset <- "global"
# siteset <- "fluxnet2015"
# siteset <- "rsip"
```

## Meta info

- Creates data frame with all meta info variables as separate columns.

Read site location and direct observation data.
```{r}
if (siteset=="sj02"){
  ##----------------------------------------------
  ## Schenk & Jackson sites
  ##----------------------------------------------
  siteinfo <- read_csv("~/data/rootingdepth/root_profiles_schenkjackson02/data/root_profiles_D50D95.csv") %>%
    dplyr::filter(Wetland == "N" & Anthropogenic == "N" & Schenk_Jackson_2002 == "YES") %>% 
    dplyr::rename(sitename = ID, lat = Latitude, lon = Longitude) %>% 
    dplyr::mutate(elv = ifelse(elv==-999, NA, elv)) %>% 
    dplyr::filter(lon!=-999 & lat!=-999) %>% 
    dplyr::select(sitename, lon, lat, elv)

  df_grid_allsiteid <- siteinfo %>% 
    dplyr::select(sitename, lon, lat, elv) %>% 
    dplyr::rename(idx = sitename)

  df_grid <- df_grid_allsiteid %>%
    dplyr::select(lon, lat) %>%
    distinct() %>%
    mutate(idx = 1:n()) %>%
    mutate(idx = paste0("i", idx))

} else if (siteset == "fluxnet2015"){
  ##----------------------------------------------
  ## FLUXNET 2015 Tier 1 sites
  ##----------------------------------------------
  siteinfo <- ingestr::siteinfo_fluxnet2015 %>% 
    rename(sitename = mysitename) %>% 
    filter(!(classid %in% c("CRO", "WET"))) %>% 
    #filter(year_start<=2007) %>%    # xxx USE ONLY FOR LANDEVAL xxx
    mutate(date_start = lubridate::ymd(paste0(year_start, "-01-01"))) %>% 
    mutate(date_end = lubridate::ymd(paste0(year_end, "-12-31")))

  df_grid <- siteinfo %>% 
    dplyr::select(sitename, lon, lat, elv) %>% 
    dplyr::rename(idx = sitename)

} else if (siteset == "global"){
  ##----------------------------------------------
  ## Global simulations at 0.5 degrees
  ##----------------------------------------------
  ## use WFDEI land mask and read its elevation
  df <- nc_to_df("~/data/watch_wfdei/WFDEI-elevation.nc", dropna = TRUE) %>% 
    mutate(sitename = paste0("i", 1:n())) %>% 
    rename(elv = myvar) %>% 
    dplyr::select(sitename, lon, lat, elv)
}
```

### Elevation

- Fills missing values in column `elv`.
    - Site scale: data or ETOPO1
    - Global: WFDEI
    
#### Global

First, regrid ETOPO1 file and save as NetCDF (Done with `~/data/etopo/proc_etopo.R`). Then read it in.
```{r}
df_elv <- nc_to_df(
  "~/data/etopo/ETOPO1_Bed_g_gef.tif_halfdeg.nc",
  varnam = "ETOPO1_Bed_g_geotiff"
  )
```

#### Site-level

Extract points from ETOPO1 GeoTIFF file and add to siteinfo.
```{r}
if (siteset != "global"){
  ##----------------------------------------------
  ## Site-scale set
  ##----------------------------------------------
  siteinfo <- siteinfo %>% 
    left_join(
      ingest(
        siteinfo %>% 
          dplyr::select(sitename, lon, lat),
        source = "etopo1",
        dir = "~/data/etopo/"
    ) %>% 
    unnest(data) %>% 
    rename(elv_etopo = elv),
      by = "sitename"
    )

  ## Show a comparison
  modobs_elv <- siteinfo %>% 
    analyse_modobs2("elv", "elv_etopo")

  ## Replace missing
  siteinfo <- siteinfo %>% 
    mutate(source_elv = ifelse(is.na(elv), "etopo1", "orig_data")) %>% 
    mutate(elv = ifelse(is.na(elv), elv_etopo, elv)) %>% 
    dplyr::select(-elv_etopo)
}
```    
    
### Soil texture    
-  Derive WHC top and bottom, and record obstacles to root used in function `calc_zroot.R`. Adds columns `data_soiltext_top` and `data_soiltext_sub`.
    - Site scale: HWSD
    - Global: HWSD-Wieder
    
#### Global

Get data from rasterized HWSD data by Wieder. Data frame has row for each gridcell and nested data frames in `data`,  containing columns `T_CLAY, T_GRAVEL, T_OC, T_SAND, S_CLAY, S_GRAVEL, S_OC, S_SAND, ROOTS, IL`
```{r}
## first get subsoil parameters
df_hwsd <- rbeni::nc_to_df("~/data/soil/hwsd/hwsd_wieder/data/S_SAND.nc4", "S_SAND") %>%
  rename( S_SAND = myvar ) %>%
  tidyr::drop_na() %>% 
  
  left_join(
    rbeni::nc_to_df("~/data/soil/hwsd/hwsd_wieder/data/S_CLAY.nc4", "S_CLAY") %>%
      rename( S_CLAY = myvar ),
    by = c("lon", "lat")
  ) %>%
  left_join(
    rbeni::nc_to_df("~/data/soil/hwsd/hwsd_wieder/data/S_OC.nc4", "S_OC") %>%
      rename( S_OC = myvar ),
    by = c("lon", "lat")
  ) %>%
  left_join(
    rbeni::nc_to_df("~/data/soil/hwsd/hwsd_wieder/data/S_GRAVEL.nc4", "S_GRAVEL") %>%
      rename( S_GRAVEL = myvar ),
    by = c("lon", "lat")
  ) %>%

  ## get topsoil parameters
  left_join(
    rbeni::nc_to_df("~/data/soil/hwsd/hwsd_wieder/data/T_SAND.nc4", "T_SAND") %>%
      rename( T_SAND = myvar ),
    by = c("lon", "lat")
  ) %>%
  left_join(
    rbeni::nc_to_df("~/data/soil/hwsd/hwsd_wieder/data/T_CLAY.nc4", "T_CLAY") %>%
      rename( T_CLAY = myvar ),
    by = c("lon", "lat")
  ) %>%
  left_join(
    rbeni::nc_to_df("~/data/soil/hwsd/hwsd_wieder/data/T_OC.nc4", "T_OC") %>%
      rename( T_OC = myvar ),
    by = c("lon", "lat")
  ) %>%
  left_join(
    rbeni::nc_to_df("~/data/soil/hwsd/hwsd_wieder/data/T_GRAVEL.nc4", "T_GRAVEL") %>%
      rename( T_GRAVEL = myvar ),
    by = c("lon", "lat")
  ) %>% 

  left_join(
    rbeni::nc_to_df("~/data/soil/hwsd/hwsd_wieder/data/ROOTS.nc4", "ROOTS") %>%
      rename( ROOTS = myvar ),
    by = c("lon", "lat")
  )

save(df_hwsd, file = "data/df_hwsd_hires.RData")
```

For global simulations, get soil parameters using the R script `rscript_calc_soilparams.R` (with `submit_calc_soilparams.sh`) and combine files with `rscript_combine_df_whc.R`.

For site-level simulations do:
```{r}
load("data/df_hwsd_hires.RData")

if (siteset!="global"){
 
df_whc <- df_hwsd %>% 
  slice(100000:100020) %>% ## this takes forever. send it to cluster,
  group_by(lon, lat) %>% 
  nest() %>% 
  mutate(
    data_soiltext_top = purrr::map(data, ~dplyr::select(
      ., fclay = T_CLAY, fgravel = T_GRAVEL, forg = T_OC, fsand = T_SAND, roots = ROOTS)),
    data_soiltext_sub = purrr::map(data, ~dplyr::select(
      ., fclay = S_CLAY, fgravel = S_GRAVEL, forg = S_OC, fsand = S_SAND, roots = ROOTS))
    ) %>% 
  dplyr::select(-data) %>% 
  mutate(data_soiltext_top = purrr::map(data_soiltext_top, ~calc_soilparams(., method = "balland")),
         data_soiltext_sub = purrr::map(data_soiltext_sub, ~calc_soilparams(., method = "balland")))
}
```

#### Site-level

Extract point data from shapefile using `ingestr::ingest()`.
```{r}
if (siteset != "global"){
  ##----------------------------------------------
  ## Site-scale set
  ##----------------------------------------------
  ## Collect HWSD data from database
  filn <- paste0("data/df_hwsd_", siteset, ".RData")
  if (!file.exists(filn)){
    df_hwsd <- ingest(
      siteinfo,
      source = "hwsd",
      settings = list(fil = "~/data/hwsd/HWSD_RASTER/hwsd.bil")
      )
    save(df_hwsd, file = filn)
  } else {
    load(filn)
  }

  ## Calculate FC, PWP, and WHC from texture data.
  filn <- paste0("data/df_whc_", siteset, ".RData")
  if (!file.exists(filn)){
    df_whc <- df_hwsd %>% 
      mutate(data = purrr::map(data, ~slice(., 1))) %>% 
      mutate(
        data_soiltext_top = purrr::map(data, ~dplyr::select(
          ., fclay = T_CLAY, fgravel = T_GRAVEL, forg = T_OC, fsand = T_SAND, roots = ROOTS, imperm = IL)),
        data_soiltext_sub = purrr::map(data, ~dplyr::select(
          ., fclay = S_CLAY, fgravel = S_GRAVEL, forg = S_OC, fsand = S_SAND, roots = ROOTS, imperm = IL))
        ) %>% 
      dplyr::select(-data) %>% 
      mutate(data_soiltext_top = purrr::map(data_soiltext_top, ~calc_soilparams(., method = "balland")),
             data_soiltext_sub = purrr::map(data_soiltext_sub, ~calc_soilparams(., method = "balland")))

    save(df_whc, file = filn)
  } else {
    load(filn)
  }

} else {
  
    
  
}

## add to meta data table
siteinfo <- siteinfo %>% 
  left_join(df_whc, by = "sitename")
```

### WTD

- Fan et al.
    - Site scale: Hi-res Fan
    - Global: Lo-res Fan

```{r}
if (siteset != "global"){
  ##----------------------------------------------
  ## Site-scale set
  ##----------------------------------------------
  ## Collect HWSD data from database
  filn <- paste0("data/df_wtd_fan_", siteset, ".RData")
  if (!file.exists(filn)){
    df_wtd <- siteinfo %>% 
      dplyr::select(sitename, lon, lat) %>% 
      ingest_wtd_fan()
    save(df_wtd, file = filn)
  } else {
    load(filn)
  }

}

## add to meta data table
siteinfo <- siteinfo %>% 
  left_join(df_wtd %>% 
              dplyr::select(sitename, wtd), 
            by = "sitename"
            )
```

### Biome

- WWF, NSCP?
    - Site scale: WWF, extract from shapefile
    - Global: rasterize WWF data?
    
#### Global

Rasterize shapefile to high resolution global map.
```{r}
library(rgdal)

# read in the polygons
# shape <- readOGR("/alphadata01/bstocker/data/biomes/olson2001_teow/wwf_terr_ecos.shp")
shape <- readOGR("~/data/biomes/wwf_ecoregions/official/wwf_terr_ecos.shp")

# create empty raster
rasta <- raster(nrows=3600, ncols=7200, xmx=180, ymn=-90, ymx=90, crs=CRS("+init=EPSG:4326"))

# convert polygons to 1x1 raster
rasta_biome <- rasterize(shape, rasta, background=NA, field="BIOME")
#plot(rasta_biome)

# remove no data values
rasta_biome[rasta_biome %in% c(98, 99)] <- NA

# convert raster to factor
rasta_biome <- as.factor(rasta_biome)

# save to files
saveRDS( rasta_biome, "~/data/biomes/wwf_ecoregions/official/wwf_terr_ecos_raster.rds")

writeRaster( rasta_biome, "~/data/biomes/wwf_ecoregions/official/wwf_terr_ecos_raster.nc", 
             overwrite=TRUE, format="CDF", varname="biome", varunit="category", 
             longname="WWF ecoregions biome", xname="lon", yname="lat"
             )
```

#### Site-level
    
```{r}
if (siteset != "global"){
  ##----------------------------------------------
  ## Site-scale set
  ##----------------------------------------------
  ## WWF biome (Ecoregions dataset)
  filn <- paste0("data/df_biome_wwf_", siteset, ".RData")
  if (!file.exists(filn)){
    
    df_wwf <- ingest(
      dplyr::select(siteinfo, sitename, lon, lat),
      source = "wwf",
      dir = "~/data/biomes/wwf_ecoregions/official/",
      settings = list(layer = "wwf_terr_ecos")
      ) %>% 
      mutate(data = purrr::map(data, ~slice(., 1)))
    
    save(df_wwf, file = filn)
  } else {
    load(filn)
  }
}

## add to meta data table
siteinfo <- siteinfo %>% 
  left_join(df_wwf %>% 
              mutate(data = purrr::map(data, ~dplyr::select(., biome_id = BIOME, biome_name = BIOME_NAME))) %>%
              tidyr::unnest(data), 
            by = "sitename"
            )
```
    
### Save meta info

```{r}
filn <- paste0("data/siteinfo_", siteset, ".RData")
save(siteinfo, file = filn)

load(filn)
# filn <- paste0("data/siteinfo_", siteset, ".csv")
# siteinfo %>% 
#   tidyr::unnest(c(data_soiltext_top, data_soiltext_sub)) %>% 
#   write_csv(path = filn)
```


## Extract data

`rscript_get_data.R`  Creates separate data frames for each data source, rows: site/gridcell, column: nested data, data: ET (W m-2), prec, snow, temp, elevation; large data! need to separate data frames by chunks for global analyses

### ALEXI

Test plot.
```{r}
library(sf)
library(raster)
library(rasterVis)
nc <- read_nc_onefile("~/data/alexi_tir/netcdf/EDAY_CERES_2006200.nc")

## crop and write smaller file
rasta <- raster("~/data/alexi_tir/netcdf/EDAY_CERES_2006200.nc")
lonmin <- 0
lonmax <- 180
latmin <- 50
latmax <- 80
rasta2 <- crop(rasta, extent(lonmin, lonmax, latmin, latmax))
raster::writeRaster(rasta2, filename = "./data/maptest.nc", format = "CDF", overwrite = TRUE )
plot_map3("./data/maptest.nc", lonmin = lonmin, lonmax = lonmax, latmin = latmin, latmax = latmax)
```

```{r}
if (siteset=="global"){
  
  ## run scripts `rscript_get_data_alexi.sh` and `rscript_get_data_alexi_lores.sh` on Euler by
  # system("./submit_get_data_alexi.sh")
  # system("./submit_get_data_alexi_lores.sh")
  
} else {
  ##------------------------------------------------------------------------
  ## Extract point data and construct single nested time series data frame
  ##------------------------------------------------------------------------
  filn <- paste0("data/df_alexi_", siteset,".Rdata")
  filn_csv <- str_replace(filn, "RData", "csv")
  if (!file.exists(filn)){
    if (!file.exists(filn_csv)){
      df_alexi <- get_data_mct_global(
        df_grid,
        dir_et   = "~/data/alexi_tir/netcdf/", fil_et_pattern = "EDAY_CERES_",
        get_watch = FALSE, get_landeval = FALSE, get_alexi = TRUE
      )
      save(df_alexi, file = filn)
      df_alexi %>%
        tidyr::unnest(df) %>%
        write_csv(path = filn_csv)
    } else {
      df_alexi <- read_csv(file = filn_csv) %>%
        group_by(idx, lon, lat) %>%
        tidyr::nest() %>%
        dplyr::mutate(data = purrr::map(data, ~as_tibble(.))) %>%
        dplyr::rename(df = data)
    }
  } else {
    load(filn)
    df_alexi %>%
      tidyr::unnest(df) %>%
      write_csv(path = filn_csv)
  } 
}
```

### WATCH

```{r}
##------------------------------------------------------------------------
## WATCH
##------------------------------------------------------------------------
filn <- paste0("data/df_watch_", siteset,".RData")
filn_csv <- str_replace(filn, "RData", "csv")
if (!file.exists(filn)){
  if (!file.exists(filn_csv)){
    df_watch <- get_data_mct_global(
      df_grid,
      dir_prec = "~/data/watch_wfdei/Rainf_daily/", fil_prec_pattern = "Rainf_daily_WFDEI_CRU",
      dir_snow = "~/data/watch_wfdei/Snowf_daily/", fil_snow_pattern = "Snowf_daily_WFDEI_CRU",
      dir_temp = "~/data/watch_wfdei/Tair_daily/",  fil_temp_pattern = "Tair_daily_WFDEI",
      get_watch = TRUE, get_landeval = FALSE, get_alexi = FALSE,
      year_start_watch = 2003, year_end_watch = 2018
    )
    save(df_watch, file = filn)
    df_watch %>%
      tidyr::unnest(data) %>%
      write_csv(path = filn_csv)
  } else {
    df_watch <- read_csv(file = filn_csv) %>%
      group_by(sitename) %>%
      tidyr::nest() %>%
      dplyr::mutate(data = purrr::map(data, ~as_tibble(.))) %>%
      dplyr::rename(df = data)
  }
} else {
  load(filn)
  df_watch %>%
    tidyr::unnest(data) %>%
    write_csv(path = filn_csv)
}
```

### SIF

`rscript_get_data_sif_jj.R` and `rscript_get_data_sif_pk.R`: Rearranging data from maps to time series data frames. Output is stored in `~/data/gome_2_sif_downscaled/data_tidy/`.

<!-- ```{r} -->
<!-- source("R/get_data_mct_global.R") # because this function is defined also in another source file - mess -->
<!-- ##------------------------------------------------------------------------ -->
<!-- ## SiF-downscaled from Duveiller -->
<!-- ##------------------------------------------------------------------------ -->
<!-- filn <- paste0("data/df_sif_", siteset, ".RData") -->
<!-- filn_csv <- str_replace(filn, "Rdata", "csv") -->
<!-- if (!file.exists(filn)){ -->
<!--   if (!file.exists(filn_csv)){ -->

<!--     ## version 'JJ'   -->
<!--     df_sif_jj <- get_data_mct_global( -->
<!--       df_grid, -->
<!--       dir_sif  = "~/data/gome_2_sif_downscaled/data_orig/", fil_sif_pattern = "GOME_JJ_dcSIF_005deg_8day_", -->
<!--       get_watch = FALSE, get_landeval = FALSE, get_alexi = FALSE, get_sif = TRUE -->
<!--     ) -->
<!--     df_sif_jj <- df_sif_jj %>%  -->
<!--       rename(idx_uniquelonlat = idx) %>%  -->
<!--       right_join(df_grid_allsiteid, -->
<!--                  by = c("lon", "lat")) -->
<!--     save(df_sif_jj, file = filn) -->

<!--     ## version 'PK'   -->
<!--     df_sif_pk <- get_data_mct_global( -->
<!--       df_grid, -->
<!--       dir_sif  = "~/data/gome_2_sif_downscaled/data_orig/", fil_sif_pattern = "GOME_PK_dcSIF_005deg_8day_", -->
<!--       get_watch = FALSE, get_landeval = FALSE, get_alexi = FALSE, get_sif = TRUE -->
<!--     ) -->
<!--     df_sif_pk <- df_sif_pk %>%  -->
<!--       rename(idx_uniquelonlat = idx) %>%  -->
<!--       right_join(df_grid_allsiteid, -->
<!--                  by = c("lon", "lat")) -->
<!--     save(df_sif_pk, file = filn)     -->

<!--     df_sif %>% -->
<!--       tidyr::unnest(df) %>% -->
<!--       write_csv(path = filn_csv) -->

<!--   } else { -->

<!--     df_sif <- read_csv(file = filn_csv) %>% -->
<!--       group_by(idx, lon, lat) %>% -->
<!--       tidyr::nest() %>% -->
<!--       dplyr::mutate(data = purrr::map(data, ~as_tibble(.))) %>% -->
<!--       dplyr::rename(df = data) -->
<!--   } -->
<!-- } else { -->
<!--   load(filn) -->
<!--   df_sif %>% -->
<!--     tidyr::unnest(df) %>% -->
<!--     write_csv(path = filn) -->
<!-- } -->
<!-- ``` -->

### GLASS net radiation

XXX TO BE COMPLETED

Test plot.
```{r}
library(sf)
library(raster)
library(rasterVis)
nc <- read_nc_onefile("~/data/alexi_tir/netcdf/EDAY_CERES_2006200.nc")

## crop and write smaller file
rasta <- raster("~/data/glass/data_netcdf/2001/GLASS07B01.V41.A2001166.2018264.nc")
lonmin <- 0
lonmax <- 180
latmin <- 50
latmax <- 80
rasta2 <- crop(rasta, extent(lonmin, lonmax, latmin, latmax))
raster::writeRaster(rasta2, filename = "./data/maptest.nc", format = "CDF", overwrite = TRUE )
plot_map3("./data/maptest.nc", lonmin = lonmin, lonmax = lonmax, latmin = latmin, latmax = latmax)
```

    
## Combine, convert units, complement, reduce 

### Data filtering

Some ET data seem to be missing. Retain only sites with more than 3000 ET dates.
```{r}
n_avl_et <- function(df){
  sum(!is.na(df$et))
}

df_alexi <- df_alexi %>% 
  mutate(avl_et = purrr::map_int(df, ~n_avl_et(.))) 

## where are they? They are along coasts. Ok, valid to remove them.
plot_map_simpl() +
  geom_point(
    data = df_alexi %>% 
      dplyr::filter(avl_et < 3000),
    aes(lon, lat),
    color = 'red')

df_alexi <- df_alexi %>% 
  dplyr::filter(avl_et > 3000)
```

Manipulates data frames prepared by step 2, reduced data frames with only 1 column: daily water balance (not cumulative!)

### ET in mm

#### Global

- Convert units to get ET in mm. Run scripts `submit_get_et_mm.sh` to run `rscript_get_et_mm.R`.

#### Site-level
```{r}
filn <- paste0("data/df_clean_", siteset, ".RData")
if (!file.exists(filn)){
  
  df_clean <- df_alexi %>%
    ungroup() %>% 
    
    # ## xxx debug
    # dplyr::filter(idx == "BF03a") %>%

    ## add elevation to the nested dataframes (repeating same value for each time step)
    tidyr::unnest(df) %>%
    drop_na(date) %>% 
    dplyr::select(-elv) %>% 
    left_join(dplyr::select(siteinfo, idx = sitename, elv),
              by = "idx") %>%
    dplyr::group_by(lon, lat, idx) %>%
    tidyr::nest() %>%

    ## convert units: get ET in mm d-1
    ## total ET
    dplyr::mutate(et_mm = purrr::map(data, ~convert_et(.$et, .$temp, .$elv))) %>% 
    dplyr::mutate(et_mm = purrr::map(et_mm, ~tibble(et_mm = .))) %>% 
    dplyr::mutate(data    = purrr::map(data, ~dplyr::select(., -et_mm))) %>% 
    dplyr::mutate(data    = purrr::map2(data, et_mm, ~bind_cols(.x, .y))) %>% 
    dplyr::select(-et_mm) %>% 
    dplyr::mutate(data    = purrr::map(data, ~drop_na(., date)))  # Problem: The first row in `df_alexi$df` is always NA. This is a bug. Drop the row.

  # ## get flat table
  # df_clean <- df_alexi %>% 
  #   
  #   ## clean something weird
  #   group_by(idx) %>% 
  #   nest() %>% 
  #   mutate(data = purrr::map(data, ~slice(., 1))) %>% 
  #   unnest(data) %>% 
  #   
  #   ## make flat
  #   unnest(df) %>% 
  #   rename(sitename = idx)
  # 
  # ## add prec and snow from df_watch
  # avl_prec_snow <- ("prec" %in% names(df_clean) && "snow" %in% names(df_clean))
  # if (!avl_prec_snow){
  #   df_clean <- df_clean %>% 
  #     left_join(df_watch %>% 
  #                 unnest(data),
  #               by = "sitename")
  # }
  # 
  # ## Get ET in mm
  # avl_et_mm <- "et_mm" %in% names(df_clean)
  # if (!avl_et_mm){
  #   
  #   avl_elv <- "elv" %in% names(df_clean)
  #   if (!avl_elv){
  #     ## get elevation data from siteinfo
  #     df_clean <- df_clean %>% 
  #       left_join(dplyr::select(siteinfo, sitename, elv),
  #                 by = "sitename")
  #   }
  #   
  #   avl_temp <- ("temp" %in% names(df_clean))
  #   if (!avl_temp){
  #     df_clean <- df_clean %>% 
  #       left_join(df_watch %>% 
  #                   unnest(data) %>% 
  #                   dplyr::select(sitename, temp),
  #                 by = "sitename"
  #                )
  #   }
  #   
  #   ## Apply conversion function
  #   df_clean <- df_clean %>% 
  #     rowwise() %>% 
  #     mutate(et_mm = convert_et(et, temp, elv)) %>% 
  #     
  #     ## nest again for next step
  #     group_by(sitename) %>% 
  #     tidyr::nest() %>% 
  #     
  #     ## interpolate missing values in et_mm
  #     mutate(data = purrr::map(data, ~myapprox(.$et_mm)))
  #   
  # }
  
  # ## nest again, if unnested
  # unnested <- (df_clean$sitename %>% table() %>% as_tibble() %>% slice(1) %>% pull(n) > 1)
  # if (unnested){
  #   df_clean <- df_clean %>% 
  #     group_by(sitename) %>% 
  #     nest()
  # }
    
  save(df_clean, file = filn)  

} else {
  load(filn)
}
```

### Snow

#### Global

Run script `rscript_simulate_snow.R` on Euler (submission file: `submit_simulate_snow.R`).

#### Site-level

```{r}
filn <- paste0("data/df_snow_", siteset, ".RData")
if (!file.exists(filn)){

  ## Simulate snow water balance (no missing data allowed for 'prec', 'snow', or 'temp')
  avl_snow_pool <- ("snow_pool" %in% names(df_clean$data[[1]]) && "liquid_to_soil" %in% names(df_clean$data[[1]]))
  n_avl_prec <- function(df){
    sum(is.na(df$prec))
  }
  n_avl_snow <- function(df){
    sum(is.na(df$snow))
  }
  n_avl_temp <- function(df){
    sum(is.na(df$temp))
  }

  # ## debug
  # df_clean <- df_clean %>% 
  #   mutate(missing_snow = purrr::map_int(data, ~n_avl_snow(.))) %>% 
  #   mutate(missing_prec = purrr::map_int(data, ~n_avl_prec(.))) %>% 
  #   mutate(missing_temp = purrr::map_int(data, ~n_avl_temp(.)))
  # df_test <- df_clean %>% 
  #   dplyr::filter(missing_snow > 1 | missing_prec > 1 | missing_temp > 1 )
  
  
  df_snow <- df_clean %>% 
    mutate(data = purrr::map(data, ~drop_na(., date))) %>% 
    mutate(data = purrr::map(data, ~simulate_snow(.)))
  
  save(df_snow, file = filn)
  
  # ## test plot visualising snow accumulation and melt
  # df_snow$data[[1]] %>%
  #    dplyr::filter(lubridate::year(date) == 2005) %>%
  #    ggplot() +
  #    geom_line(aes(date, snow_pool), col = "royalblue") +
  #    geom_line(aes(date, liquid_to_soil), col = "springgreen4") +
  #    geom_line(aes(date, prec), col = "tomato")

} else {
  load(filn)
}
```

### Daily water balance 

#### Global

Run script `rscript_get_bal.R` on Euler (submission file: `submit_get_bal.R`).

#### Site-level

... and reduce data frames.
```{r} 
source("R/get_bal.R")

filn <- paste0("data/df_bal_", siteset, ".RData")
if (!file.exists(filn)){

  avl_et <- function(df, varnam_et){
    any(!is.na(df[varnam_et]))
  }

  df_bal <- df_snow %>%
    
    # ## xxx debug
    # dplyr::filter(idx == "BF03a")
    
    dplyr::mutate( data = purrr::map(data, ~get_bal(., varnam_bal = "bal", varnam_prec = "liquid_to_soil", varnam_et = "et_mm"))) %>% 
    dplyr::mutate( avl_et = purrr::map_lgl(data, ~avl_et(., varnam_et = "et_mm"))) %>%
    dplyr::filter( avl_et ) %>% 
    dplyr::mutate( data = purrr::map(data, ~dplyr::select(., date, bal)))
    
  save(df_bal, file = filn)  

} else {
  load(filn)
}
```

    
### CWD events and extremes

Do both in one step. function `get_plantwhc_mct_bysite()` returns the CWD time series and events data frame (output from `mct()`), as well as the return periods data frame and the fitted model for the extreme value distribution 

`mct2.R`  Creates list with (i) water deficit time series, daily and cumulative, dday, iinst; and (ii) events data frame with maximum deficit, start date and length of event

- Use parameters determined from FLUXNET-sites analysis (`thresh_terminate = 0.0, thresh_drop = 0.9`)


#### Global

Run script `rscript_get_cwdx.R` on Euler (submission file: `submit_get_cwdx.R`).


#### Site-level

```{r}
filn <- paste0("data/df_cwd_", siteset, ".RData")
if (!file.exists(filn)){
  df_cwd <- df_bal %>% 
    dplyr::mutate(
      out_mct = purrr::map(
        data,
        ~get_plantwhc_mct_bysite(
          .,
          varname_wbal = "bal",
          thresh_terminate = 0.0,
          thresh_drop = 0.9,
          fittype = "Gumbel"))
      )
  save(df_cwd, file = filn)
} else {
  load(filn)
}
```


## Extract CWDXX

Extract CWD-extremes from full output.

### Global

Run `rscript_extract_cwdx.R` (with submit file `submit_extract_cwdx.sh`).


## Check file availability

On Euler, run `rscript_check_files.R` and download the overview dataframe it writes (`data/df_file_availability.RData`)

```{r}
load("data/df_file_availability_bal_only.RData")
```

Longitude slices for which now snow files are available -> Possibly no WATCH-WFDEI gridcell at respective longitude? All available!
```{r}
df %>% 
  dplyr::filter(!avl_snow)
```

Longitude slices without tidy ALEXI data. All available!
```{r}
df %>% 
  dplyr::filter(!avl_tidy)
```

Longitude slices without ET-mm data (written by `R/get_et_mm_bylon.R`). 
All available.
```{r}
df %>% 
  dplyr::filter(!avl_et_mm)
```

Longitude slices without `bal` data. All available.
```{r}
df %>% 
  dplyr::filter(!avl_bal)
```

Longitude slices without CWDX data. All available.
```{r}
df %>% 
  ungroup() %>% 
  dplyr::filter(!avl_cwdx)
```

Longitude slices without extracted CWDX data. All available.
```{r}
df %>% 
  dplyr::filter(!avl_cwdx_10_20_40 & avl_cwdx & avl_bal & avl_et_mm)
```

Total not available extracted CWDX data (longitude slices): 1,476
```{r}
df %>% 
  ungroup() %>% 
  dplyr::filter(!avl_cwdx_10_20_40)
```


## Collect data

For the global application, combine WHCX and soil texture information into a global common data frame. Run `rscript_collect_cwdx.R`
```{r}
## CWDX data
load("data/df_cwdx_10_20_40.RData") # loads 'df', created by rscript_collect_cwdx.R

df <- df %>% 
  mutate(lon = round(lon, digits = 3), lat = round(lat, digits = 3)) 
```

### Write NetCDF

```{r}
nc <- df_to_grid(df, varnam = "cwdx20", lonnam = "lon", latnam = "lat")
write_nc2(nc, varnams = "cwdx20", lon = df$lon %>% unique() %>% sort(), lat = df$lat %>% unique() %>% sort(), path = "data/cwdx20.nc", make_zdim = FALSE)
```

Regrid to 0.5 deg
```{r}
system("cdo remapbil,gridfile_halfdeg.txt data/cwdx20.nc data/cwdx20_halfdeg.nc")
```

Read half-degree global file and plot.
```{r}
nc_halfdeg <- read_nc_onefile("data/cwdx20_halfdeg.nc", varnam = "cwdx20")
plot_map3(nc_halfdeg, varnam = "cwdx20", breaks = c(seq(0, 100, by = 20), 150, 200, 300, 500, 1000, 1500), latmin = -55, latmax = 80,
          spacing = "constant")
ggsave("fig/map_cwdx20.pdf", width = 10, height = 6)

## over the indian ocean
gg <- plot_map3(nc_halfdeg, varnam = "cwdx20", breaks = c(seq(0, 100, by = 20), 150, 200, 300, 500, 1000, 1500), latmin = 0, latmax = 25, lonmin = 50, lonmax = 80,
          spacing = "constant")

# ggsave("fig/map_cwdx20.pdf", width = 10, height = 8)
```

## Test plots

### Maps

Problem with missing data for certain gridcells. Solutions with varying `thresh_terminate` and with rounding digits of longitude and latitude values. 
```{r}
## spain
gg <- df %>% 
  dplyr::filter(lon > -10 & lon < 5 & lat > 35 & lat < 45) %>% 
  plot_map3(varnam = "cwdx20", lonmin = -10, lonmax = 5, latmin = 35, latmax = 45)

## andalusia
gg <- df %>% 
  dplyr::filter(lon > -7 & lon < -4 & lat > 36 & lat < 37.5) %>% 
  plot_map3(varnam = "cwdx20", lonmin = -7, lonmax = -4, latmin = 36, latmax = 37.5, combine = TRUE)

## weird zero-meridian values
gg <- df %>% 
  dplyr::filter(lon > -2 & lon < 2 & lat > 42 & lat < 43) %>% 
  plot_map3(varnam = "cwdx20", lonmin = -2, lonmax = 2, latmin = 42, latmax = 43)

vec_lon_missing <- df %>% 
  dplyr::filter(lon > -2 & lon < 2 & lat > 42 & lat < 43) %>% 
  filter(is.na(cwdx20)) %>% 
  pull(lon) %>% 
  unique() %>% 
  round(digits = 3)

## Missing data for these ilon:
lon_hires <- seq(-179.975, 179.975, by = 0.05) %>% round(digits = 3)
which(lon_hires %in% vec_lon_missing)

## example missing point:
df_missing <- df %>% 
  dplyr::filter(near(lon, -6.225, tol = 0.0001) & near(lat, 37.025, tol = 0.0001))

gg$ggmap +
  geom_point(aes(x = df_missing$lon, y = df_missing$lat), color = "red", size = 2)

## open df_cwdx where the missing cell is contained
load("data/df_cwdx/df_cwdx_ilon_3476.RData")

## is missing
out_mct <- df %>% 
  dplyr::filter(near(lon, -6.225, tol = 0.0001) & near(lat, 37.025, tol = 0.0001)) %>% 
  pull(out_mct)

## open df_bal where the missing cell is contained
load("data/df_bal/df_bal_ilon_3476.RData")

## df_bal data is not missing
df %>% 
  dplyr::filter(near(lon, -6.225, tol = 0.0001) & near(lat, 37.025, tol = 0.0001)) %>% 
  #dplyr::filter( lon == -6.225 & lat == 37.025 ) %>% 
  pull(data)

## take example of missing cells in andalusia:
df_test <- df %>% 
  dplyr::filter(lon > -7 & lon < -4 & lat > 36 & lat < 37.5) %>% 
  dplyr::filter(is.na(cwdx20)) %>% 
  slice(1)

lon <- df_test$lon  # is -6.225
uselat <- df_test$lat  # is 37.025
lon_hires <- seq(-179.975, 179.975, by = 0.05)
ilon_hires <- which.min(abs(lon_hires - -6.225))
```

Some ocean gridcells have values for cwdx. (latmin = 0, latmax = 25, lonmin = 50, lonmax = 80)
```{r}
## indian ocean
gg <- df %>% 
  dplyr::filter(lon > 50 & lon < 80 & lat > 0 & lat < 25) %>% 
  plot_map3(varnam = "cwdx20", latmin = 0, latmax = 25, lonmin = 50, lonmax = 80, combine = FALSE)

gg$ggmap +
  geom_point(aes(x = 65.025, y = 10.025), color = "red", size = 2)

## The value is 36.85907 for a gridcell in the middle of the ocean.
df %>% 
  dplyr::filter(lon == 65.025, lat == 10.025)

which.min(abs(lon_hires - 65.025))
```









More test plots
```{r}
## europe
out <- df %>% 
  dplyr::filter(lon > -5 & lon < 25 & lat > 35 & lat < 55) %>% 
  plot_map3(varnam = "cwdx20", lonmin = -5, lonmax = 25, latmin = 35, latmax = 55, breaks = c(seq(0, 100, by = 20), 150, 200, 300, 500, 1000, 1500))
```

## Re-do failed

Method failed for some pixes, where CWD events spanned multiple years (terminate-threshold was never reached). Re-run them with updated function where `thresh_terminate` is successively increased by 0.2. This is done by `rscript_redo_failed.R` (submitted via `submit_redo_failed.sh`)


## Rooting depth z(CWDX) 

This requires WHC data.
```{r}
## WHC, prepared by rscript_combine_df_whc.R, rscript_calc_soilparams.R, and code above writing "data/df_hwsd_hires.RData"
load("data/df_whc_hires.RData") # loads 'df_whc'

## biome info
df_biome <- nc_to_df("~/data/biomes/wwf_ecoregions/official/wwf_terr_ecos_raster.nc", varnam = "biome") %>% 
  rename(biome = myvar) %>% 
  tidyr::drop_na(biome)

load("data/df_cwdx_10_20_40.RData") # loads 'df', as done already above, created by rscript_collect_cwdx.R

## merge
df <- df %>% 
  left_join(df_biome, by = c("lon", "lat")) %>% 
  left_join(df_whc, by = c("lon", "lat"))
```

### Calculate

See `mct_sj02_simsuite.Rmd`, creates data frame with z(CWDX) for different return periods

- Use 20 year return period for good match of obs and mod at SJ02 sites (see ridges plot)
- Use soil texture and WTD meta info prepared in step 1, see `mct_sj02_simsuite.Rmd`

```{r}
filn <- paste0("data/df_zroot_", siteset, ".RData")
if (!file.exists(filn)){

  ## use CWDXX for zroot, no root obstacles accounted for now
  df_zroot <- df_cwd %>%
    ungroup() %>% 
    dplyr::select(sitename = idx, out_mct) %>% 
    left_join(
      df_whc %>% 
        unnest(data_soiltext_sub) %>%
        dplyr::select(sitename, whc_s = whc),
      by = "sitename"
    ) %>% 
    left_join(
      df_whc %>% 
        unnest(data_soiltext_top) %>%
        dplyr::select(sitename, whc_t = whc, roots, imperm),
      by = "sitename"
    ) %>% 
    # dplyr::select(sitename) %>% 
    
    ## rooting depth from 20-year extreme
    dplyr::mutate(cwdx10 = purrr::map_dbl(out_mct, ~extract_return_level(., 10)),
                  cwdx20 = purrr::map_dbl(out_mct, ~extract_return_level(., 20)),
                  cwdx30 = purrr::map_dbl(out_mct, ~extract_return_level(., 30))
                  ) %>% 

    ## rooting depth from 10-year extreme
    rowwise() %>% 
    dplyr::mutate(zroot_cwd10 = calc_zroot(cwdx10, whc_t, whc_s, roots, imperm),
                  zroot_cwd20 = calc_zroot(cwdx20, whc_t, whc_s, roots, imperm),
                  zroot_cwd30 = calc_zroot(cwdx30, whc_t, whc_s, roots, imperm)
                  )

  save(df_zroot, file = filn)
  
} else {
  load(filn)
}
```


## Implied zroot using SiF: CWD(LUE=0)

### Global

Run script that wraps `calc_cwd_lue0_byilon()` and `calc_cwd_lue0()`. Collects CWD data (including instances), SIF data, and WATCH-WFDEI SWdown data into one data frame per pixel and determines sensitivity (linear regression slope) of SIF vs. CWD and SIF/SW (nSIF) vs. CWD. Also determines fractional reduction in SIF and nSIF in highest CWD bin (using function `get_flue_cwdmax()`).


### Site-level

Script used for testing at FLUXNET sites: `test_mct_bysite_alexi_fluxnet.R` 

- Use CWD events from step 3 and SiF from step 2

Add SiF data to 
```{r}
source("R/get_flue_cwdmax.R")

load("data/df_sif_jj_sj02.Rdata")
load("data/df_sif_pk_sj02.Rdata")

filn <- paste0("data/df_sif_lue0", siteset, ".Rdata")
if (!file.exists(filn)){
    
  add_mean_sif <- function(df){
    rowMeans( cbind(df$sif_jj, df$sif_pk) )
  }
    
  df_sif <- df_cwd %>% 
    dplyr::select(-data) %>% 
    mutate(cwdx40 = purrr::map_dbl(out_mct, ~extract_return_level(., 40))) %>% 
    mutate(mct = purrr::map(out_mct, "mct")) %>% 
    ungroup() %>% 
    dplyr::select(idx, mct, cwdx40) %>% 
    mutate(df = purrr::map(mct, "df"),
           inst = purrr::map(mct, "inst")) %>% 
    dplyr::select(-mct) %>% 
    
    ## add sif data
    left_join(
      df_sif_jj %>% dplyr::select(idx, df_jj = data),
      by = "idx"
    ) %>% 
    left_join(
      df_sif_pk %>% dplyr::select(idx, df_pk = data),
      by = "idx"
    ) %>% 
    dplyr::filter(!is.null(df) & !is.null(df_jj) & !is.null(df_pk) & !is.na(cwdx40)) %>% 
    mutate(df = purrr::map2(df, df_jj, ~left_join(.x, .y, by = "date"))) %>% 
    mutate(df = purrr::map(df, ~rename(., sif_jj = sif))) %>% 
    mutate(df = purrr::map2(df, df_pk, ~left_join(.x, .y, by = "date"))) %>% 
    mutate(df = purrr::map(df, ~rename(., sif_pk = sif))) %>% 
    # mutate(df = purrr::map(df, ~add_mean_sif(.))) %>% 
    mutate(df = purrr::map(df, ~rename(., lue = sif_jj))) %>%
    
    ## get CWD at LUE0=0
    mutate(out_lue0 = purrr::map2(df, inst, ~calc_cwd_lue0(.x, .y, do_plot = TRUE))) %>% 
    mutate(cwd_lue0 = purrr::map_dbl(out_lue0, "lue0")) %>% 
    mutate(cwd_lue0_exp = purrr::map_dbl(out_lue0, "lue0_exp")) %>% 
    mutate(gg = purrr::map(out_lue0, "gg")) %>% 
    
    ## get fLUE at CWDmax
    mutate(out_flue = purrr::map(df, ~get_flue_cwdmax(.))) %>% 
    mutate(flue = purrr::map_dbl(out_flue, "flue")) %>% 
    mutate(cwdmax = purrr::map_dbl(out_flue, "cwdmax")) %>% 

    dplyr::select(idx, cwdx40, cwd_lue0, cwd_lue0_exp, gg, flue, cwdmax)
    
  save(df_sif, file = filn)
} else {
  load(filn)
}

df_sif %>% 
  mutate(cwd_lue0 = remove_outliers(cwd_lue0)) %>% 
  analyse_modobs2("cwd_lue0", "cwdx20")
```
    
### LUE reduction at maximum CWD

Doesn't work well.
```{r}
df <- df_sif %>% 
  arrange(desc(flue)) %>% 
  slice(1) %>% 
  pull(df)

df_sif %>% 
  dplyr::filter(!is.na(cwd_lue0))%>% 
  ggplot(aes(x = cwdmax, y = flue)) +
  geom_point()
```
        
    
## Implied zroot using Rn: CWD(fET=0)

`test_mct_bysite_alexi_fluxnet.R`

- Use CWD events from step 3 and GLASS net radiation from step 2


## Plot 

### Rooting depth distribution

Use simulated zroot based on CWD extremes with 20-year return period.
```{r}
df_modobs <- read_csv("~/data/rootingdepth/root_profiles_schenkjackson02/data/root_profiles_D50D95.csv") %>% 
  dplyr::rename(lon = Longitude, lat = Latitude) %>% 
  dplyr::filter(lon > -180 & lat > -90) %>% 
  dplyr::filter(Wetland == "N" & Anthropogenic == "N" & Schenk_Jackson_2002 == "YES") %>% 
  dplyr::rename(sitename = ID) %>% 
  dplyr::mutate(D50 = 1000 * D50, D95 = 1000 * D95, D50_extrapolated = 1000 * D50_extrapolated, D95_extrapolated = 1000 * D95_extrapolated) %>% 
  dplyr::left_join(dplyr::select(df_zroot, cwdx20, zroot = zroot_cwd20, sitename), by = "sitename") %>% 
  left_join(siteinfo %>% 
              dplyr::select(sitename, biome_wwf = biome_name),
            by = "sitename")

save(df_modobs, file = paste0("data/df_modobs_", siteset, "WF.Rdata"))
```

Distribution by biomes.
```{r}
df_modobs %>% dplyr::select(sitename, biome_wwf, obs = D95_extrapolated, mod = zroot, lon, lat) %>% 
  tidyr::pivot_longer(cols = c(mod, obs), names_to = "source", values_to = "zroot") %>% 
  dplyr::filter(!is.na(biome_wwf)) %>% 
  dplyr::filter(biome_wwf!="Mangroves") %>%   
  ggplot(aes(x = zroot, y = biome_wwf, color = source, point_color = source, fill = source)) +
  geom_density_ridges(
    jittered_points = TRUE, scale = .95, rel_min_height = .01,
    point_shape = "|", point_size = 1.5, size = 0.25,
    position = position_points_jitter(height = 0)
  ) +
  scale_y_discrete(expand = c(0, 0)) +
  scale_x_continuous(expand = c(0, 0), name = "rooting depth (mm)") +
  scale_fill_manual(values = c("#D55E0050", "#0072B250"), labels = c("modelled", "observed")) +
  scale_color_manual(values = c("#D55E00", "#0072B2"), guide = "none") +
  scale_discrete_manual("point_color", values = c("#D55E00", "#0072B2"), guide = "none") +
  coord_cartesian(clip = "off") +
  guides(fill = guide_legend(
    override.aes = list(
      fill = c("#D55E00A0", "#0072B2A0"),
      color = NA, point_color = NA)
    )
  ) +
  ggtitle("Rooting depth by WWF biomes, SJ02 sites") +
  theme_ridges(center = TRUE)

ggsave(paste0("fig/modobs_ridges_zroot_biome_wwf_NEW", siteset, ".pdf"), width = 15, height = 10)
```

Where are locations of points with largest mismatch?
```{r}
df_tmp <- df_modobs %>% 
  mutate(error = zroot - D95_extrapolated) %>% 
  arrange(desc(error)) %>% 
  dplyr::select(sitename, zroot, D95_extrapolated, error, biome_wwf, lon, lat)

plot_map_simpl() +
  geom_point(data = df_tmp, 
             aes(lon, lat, color = error)) +
  scale_colour_gradient(low = "grey30", high = "red")
```

Are sites with largest mismatch characterised by a small reduction in flue (indicating groundwater access)?
```{r}
df_modobs %>% 
  left_join(siteinfo %>% 
              dplyr::select(sitename, biome_wwf = biome_name),
            by = "sitename") %>% 
  mutate(error = zroot - D95_extrapolated) %>% 
  arrange(desc(error)) %>% 
  dplyr::select(sitename, zroot, D95_extrapolated, error, biome_wwf) %>% 
  left_join(df_sif %>% 
              dplyr::select(sitename = idx, flue, cwdmax),
            by = "sitename") %>% 
  ggplot(aes(x = flue, y = error)) +
  geom_point()
```


### CWDX distribution

By biomes.
```{r}
df_sif %>% 
  rename(sitename = idx) %>% 
  left_join(siteinfo %>% 
              dplyr::select(sitename, biome_wwf = biome_name),
            by = "sitename") %>% 
  tidyr::pivot_longer(cols = c(cwdx20, cwd_lue0), names_to = "source", values_to = "cwd") %>% 
  dplyr::filter(!is.na(biome_wwf)) %>% 
  dplyr::filter(biome_wwf!="Mangroves") %>% 

  ggplot(aes(x = cwd, y = biome_wwf, color = source, point_color = source, fill = source)) +
  geom_density_ridges(
    jittered_points = FALSE, scale = .95, rel_min_height = .01,
    point_shape = "|", point_size = 1.5, size = 0.25,
    position = position_points_jitter(height = 0)
  ) +
  scale_y_discrete(expand = c(0, 0)) +
  scale_x_continuous(expand = c(0, 0), name = "rooting depth (mm)") +
  scale_fill_manual(values = c("#D55E0050", "#0072B250"), labels = c("CWD(LUE=0)", "CWDX")) +
  scale_color_manual(values = c("#D55E00", "#0072B2"), guide = "none") +
  scale_discrete_manual("point_color", values = c("#D55E00", "#0072B2"), guide = "none") +
  coord_cartesian(clip = "off") +
  guides(fill = guide_legend(
    override.aes = list(
      fill = c("#D55E00A0", "#0072B2A0"),
      color = NA, point_color = NA)
    )
  ) +
  ggtitle("Rooting depth by WWF biomes, SJ02 sites") +
  theme_ridges(center = TRUE)

ggsave(paste0("fig/modobs_ridges_cwd_biome_wwf_NEW", siteset, ".pdf"), width = 15, height = 10)
```

Something is wrong: Sites missing when applying new workflow. This is due to missing et_mm (elv was not ingested)
```{r}
load("data/df_modobs_reOLD.Rdata")
df_modobs_new <- dplyr::select(df_modobs, sitename, cwdx20, zroot)

df_test <- df_modobs_reOLD %>%
  dplyr::select(zroot_old = zroot, cwdx20_old = cwd20) %>%
  left_join(df_modobs_new, by = "sitename")

out <- df_test %>%
  analyse_modobs2("zroot_old", "zroot")
out$gg

out <- df_test %>%
  analyse_modobs2("cwdx20_old", "cwdx20")
out$gg
```



